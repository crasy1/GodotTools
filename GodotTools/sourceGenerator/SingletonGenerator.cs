namespace Godot;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class SingletonGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SingletonSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SingletonSyntaxReceiver receiver)
            return;

        foreach (var classDecl in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

            // 检查是否标记了 [Singleton] 特性
            if (classSymbol?.GetAttributes().Any(ad => 
                ad.AttributeClass?.Name == "SingletonAttribute") == true)
            {
                // 生成单例代码
                var source = GenerateSingletonClass(classSymbol);
                context.AddSource($"{classSymbol.Name}_Singleton.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private string GenerateSingletonClass(INamedTypeSymbol classSymbol)
    {
        string namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace 
            ? "" 
            : $"namespace {classSymbol.ContainingNamespace} {{";

        string className = classSymbol.Name;
        
        return $@"
// <auto-generated/>
#pragma warning disable
{(namespaceName != "" ? namespaceName : "")}

{(namespaceName != "" ? "    " : "")}partial class {className}
{{
    private static readonly global::System.Lazy<{className}> LazyInstance = 
        new global::System.Lazy<{className}>(() => new {className}());

    public static {className} Instance => LazyInstance.Value;

    private {className}() {{ }}
}}

{(namespaceName != "" ? "}" : "")}
";
    }
}

// 语法接收器，用于查找标记了 [Singleton] 的类
internal class SingletonSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // 查找所有包含特性的类声明
        if (syntaxNode is ClassDeclarationSyntax classDecl && 
            classDecl.AttributeLists.Count > 0)
        {
            CandidateClasses.Add(classDecl);
        }
    }
}